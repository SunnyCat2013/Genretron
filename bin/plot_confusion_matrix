#!/usr/bin/env python

import os
import argparse
import numpy as np
import matplotlib
import theano

from sklearn.metrics import confusion_matrix
from pylearn2.utils import serial, string_utils
from pylearn2.config import yaml_parse

genres = ['blues', 'classical', 'country', 'disco', 'hiphop', 'jazz', 'metal', 'pop', 'reggae', 'rock']

def get_classifier(model):
    X = model.get_input_space().make_theano_batch()
    y = model.fprop(X)
    f = theano.function([X], y, allow_input_downcast=True)
    return f

def get_dataset(model, which_set='test'):
    dataset_proxy = yaml_parse.load(model.dataset_yaml_src, instantiate=False)
    dataset_params = dataset_proxy.keywords
    if 'file' in dataset_params: # npz dataset
        dataset_params['file'] = string_utils.preprocess(dataset_params['file'])
        dataset_params['key'] = which_set + '_X'
        dataset_params['target_key'] = which_set + '_y'
    else: # mnist
        mnist_params = {
            'train': { which_set: 'train', start: 0, stop: 50000 },
            'valid': { which_set: 'train', start: 50000, stop:  60000 },
            'test' : { which_set: 'test' , stop: 10000 }
        }
        dataset_params = mnist_params[which_set]
        return dataset_proxy.callable(**dataset_params)

def one_hot_to_num(y):
    return np.argmax(y, axis=1)

def predict(classifier, X, splits):
    return np.concatenate(
        [np.argmax(classifier(np.split(X, splits)[i]), axis=1) for i in range(splits)]
    )

def plot_confusion_matrix(cm, title, cmap):
    import matplotlib.pyplot as plt
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(genres))
    plt.xticks(tick_marks, genres, rotation=45)
    plt.yticks(tick_marks, genres)
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

def make_argument_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument("model_path")
    parser.add_argument("--set", default='test')
    parser.add_argument("--splits", default=5, type=int)
    parser.add_argument("--out", default=None)

    return parser

def get_normalized_model_name(model_path):
    # assuming it ends with -best.pkl
    return os.path.basename(model_path).split('-best.pkl')[0].replace('-', '_')

def get_output_path(model_path):
    return "{0}.png".format(get_normalized_model_name(model_path))

def get_title(model_path):
    return to_natural_lang(get_normalized_model_name(model_path))

def to_natural_lang(label):
    translation = {
        'l1': r"$L_1 \lambda$",
        'hyperparameters_l1': r"$L_1 \lambda$",
        'fl': r"$FL \lambda$",
        'hyperparameters_fl': r"$FL \lambda$",
        "results_trainymisclass": "Training",
        "results_testymisclass": "Test",
        "results_validymisclass": "Validation",
        "gtzan_conv_l1_base": "GTZAN ConvNet with $L1$",
        "gtzan_conv_l1_fl_2d": "GTZAN ConvNet with $L_1$ and 2D Fused Lasso",
        "gtzan_conv_l1_fl_horiz": "GTZAN ConvNet with $L_1$ and Horizontal Fused Lasso",
        "gtzan_conv_l1_fl_vert": "GTZAN ConvNet with $L_1$ and Vertical Fused Lasso",
        "gtzan_softmax_l1_base": "GTZAN Softmax Regression with $L_1$",
        "gtzan_softmax_l1_base_bgd": "GTZAN Softmax Regression with $L_1$",
        "gtzan_softmax_l1_fl_horiz": "GTZAN Softmax Regression with $L_1$ and Horizontal Fused Lasso",
        "gtzan_softmax_l1_fl_horiz_bgd": "GTZAN Softmax Regression with $L_1$ and Horizontal Fused Lasso",
        "mnist_softmax_l1_base": "MNIST Softmax Regression with $L_1$",
        "mnist_softmax_l1_base_bgd": "MNIST Softmax Regression with $L_1$",
        "mnist_softmax_l1_fl_2d": "MNIST Softmax Regression with $L_1$ and 2D Fused Lasso",
        "mnist_softmax_l1_fl_2d_bgd": "MNIST Softmax Regression with $L_1$ and 2D Fused Lasso"
    }
    return translation[label]

def convert_shape(dataset):
    shape_converters = {
        (10,): lambda x: x,
        (513, 1, 1): lambda x: np.squeeze(x),
        (513, 216, 1): lambda x: x
    }
    return shape_converters[dataset.shape[1:]](dataset)

if __name__ == "__main__":
    parser = make_argument_parser()
    args = parser.parse_args()

    # don't require X if we are just saving the plots
    if args.out is not None:
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt

    # loads model
    print("loading model...")
    model = serial.load(args.model_path)

    # load dataset
    dataset = get_dataset(model, args.set)

    # get ground truth
    print("loading ground truth...")
    y_test = one_hot_to_num(dataset.y)

    # get predictions
    classifier = get_classifier(model)
    print("predicting...")
    y_pred = predict(classifier, dataset.X, args.splits)

    # Compute confusion matrix
    cm = confusion_matrix(y_test, y_pred)
    np.set_printoptions(precision=2)
    print('Confusion matrix, without normalization')
    print(cm)
    # plt.figure()
    # plot_confusion_matrix(cm)

    # Normalize the confusion matrix by row (i.e by the number of samples
    # in each class)
    cm_normalized = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
    print('Normalized confusion matrix')
    print(cm_normalized)
    plt.figure()
    plot_confusion_matrix(cm_normalized, get_title(args.model_path), plt.cm.Blues)

    if args.out is None:
        plt.show()
    else:
        plt.savefig(args.out, dpi=300)
