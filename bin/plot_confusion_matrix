#!/usr/bin/env python

import os
import argparse
import numpy as np
import matplotlib
import theano

from sklearn.metrics import confusion_matrix
from pylearn2.utils import serial, string_utils
from pylearn2.config import yaml_parse

genres = [ 'blues', 'classical', 'country', 'disco', 'hiphop', 'jazz', 'metal', 'pop', 'reggae', 'rock']

def get_classifier(model):
    X = model.get_input_space().make_theano_batch()
    y = model.fprop(X)
    f = theano.function([X], y, allow_input_downcast=True)
    return f

def get_dataset(model):
    dataset_proxy = yaml_parse.load(model.dataset_yaml_src, instantiate=False)
    dataset_params = {k: string_utils.preprocess(v) for k, v in dataset_proxy
                        .keywords.items()}
    dataset = np.load(dataset_params['file'])
    return dataset

def one_hot_to_num(y):
    return np.argmax(y, axis=1)

def predict(classifier, X, splits):
    return np.concatenate(
        [np.argmax(classifier(np.split(X, splits)[i]), axis=1) for i in range(splits)]
    )

def plot_confusion_matrix(cm, title, cmap):
    import matplotlib.pyplot as plt
    plt.imshow(cm, interpolation='nearest', cmap=cmap)
    plt.title(title)
    plt.colorbar()
    tick_marks = np.arange(len(genres))
    plt.xticks(tick_marks, genres, rotation=45)
    plt.yticks(tick_marks, genres)
    plt.tight_layout()
    plt.ylabel('True label')
    plt.xlabel('Predicted label')

def make_argument_parser():
    parser = argparse.ArgumentParser()

    parser.add_argument("model_path")
    parser.add_argument("-y", default='test_y')
    parser.add_argument("-X", default='test_X')
    parser.add_argument("--splits", default=5)
    parser.add_argument("--out", default=None)

    return parser

def get_normalized_model_name(model_path):
    # assuming it ends with -best.pkl
    return os.path.basename(model_path).split('-best.pkl')[0].replace('-', '_')

def get_output_path(model_path):
    return "{0}.png".format(get_normalized_model_name(model_path))

def get_title(model_path):
    return to_natural_lang(get_normalized_model_name(model_path))

def to_natural_lang(label):
    translation = {
        'l1': r"$L_1 \lambda$",
        'hyperparameters_l1': r"$L_1 \lambda$",
        'fl': r"$FL \lambda$",
        'hyperparameters_fl': r"$FL \lambda$",
        "results_trainymisclass": "Training",
        "results_testymisclass": "Test",
        "results_validymisclass": "Validation",
        "gtzan_conv_l1_base": "GTZAN ConvNet with L1",
        "gtzan_conv_l1_fl_2d": "GTZAN ConvNet with L1 and 2D Fused Lasso",
        "gtzan_conv_l1_fl_horiz": "GTZAN ConvNet with L1 and Horizontal Fused Lasso",
        "gtzan_conv_l1_fl_vert": "GTZAN ConvNet with L1 and Vertical Fused Lasso",
        "gtzan_softmax_l1_base": "GTZAN Softmax Regression with L1",
        "gtzan_softmax_l1_fl_horiz": "GTZAN Softmax Regression with L1 and Horizontal Fused Lasso",
        "gtzan_softmax_l1_fl_horiz_bgd": "GTZAN Softmax Regression with L1 and Horizontal Fused Lasso",
        "mnist_softmax_l1_base": "MNIST Softmax Regression with L1",
        "mnist_softmax_l1_base_bgd": "MNIST Softmax Regression with L1",
        "mnist_softmax_l1_fl_2d": "MNIST Softmax Regression with L1 and 2D Fused Lasso",
        "mnist_softmax_l1_fl_2d_bgd": "MNIST Softmax Regression with L1 and 2D Fused Lasso"
    }
    return translation[label]

if __name__ == "__main__":
    parser = make_argument_parser()
    args = parser.parse_args()

    # don't require X if we are just saving the plots
    if args.out is not None:
        matplotlib.use('Agg')
    import matplotlib.pyplot as plt

    # loads model
    model = serial.load(args.model_path)

    # load dataset
    dataset = get_dataset(model)

    # get ground truth
    y_test = one_hot_to_num(dataset[args.y])

    # get predictions
    classifier = get_classifier(model)
    y_pred = predict(classifier, dataset[args.X], args.splits)

    # Compute confusion matrix
    cm = confusion_matrix(y_test, y_pred)
    np.set_printoptions(precision=2)
    print('Confusion matrix, without normalization')
    print(cm)
    # plt.figure()
    # plot_confusion_matrix(cm)

    # Normalize the confusion matrix by row (i.e by the number of samples
    # in each class)
    cm_normalized = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
    print('Normalized confusion matrix')
    print(cm_normalized)
    plt.figure()
    plot_confusion_matrix(cm_normalized, get_title(args.model_path), plt.cm.Blues)

    if args.out is None:
        plt.show()
    else:
        plt.savefig(args.out, dpi=300)
