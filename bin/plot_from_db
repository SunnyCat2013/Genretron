#!/usr/bin/env python
"""
Make plots from db.
"""
import argparse
from sqlalchemy import create_engine
from genretron.utils import longest_common_substring

__authors__ = "Carmine Paolino"
__copyright__ = "Copyright 2015, Vrije Universiteit Amsterdam"
__credits__ = ["Carmine Paolino"]
__license__ = "3-clause BSD"
__email__ = "carmine@paolino.me"


def plot(results_x, results_y, xlabel, ylabels, log, out, title):
    import matplotlib
    if out:
        matplotlib.use('Agg')
    import matplotlib.pyplot as plt
    if log:
        plt.semilogx(results_x, results_y, '.-')
    else:
        plt.plot(results_x, results_y, '.-')
    ylabel = longest_common_substring(ylabels)
    if title is None:
        title = "{0} / {1}".format(ylabel, xlabel)
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend(ylabels, loc="best")
    if out:
        plt.savefig(out, format='pdf')
    else:
        plt.show()

def to_natural_lang(label):
    translation = {
        'hyperparameters_l1': "L1 lambda",
        'hyperparameters_fl': "FL lambda",
        "ymisclass": "Misclassification Error",
        "results_trainymisclass": "Train Misclass. Error",
        "results_testymisclass": "Test Misclass. Error",
        "results_validymisclass": "Valid Misclass. Error",
        "gtzan_conv_l1_base": "GTZAN ConvNet with L1",
        "gtzan_conv_l1_fl_2d": "GTZAN ConvNet with L1 and 2D FL",
        "gtzan_conv_l1_fl_horiz": "GTZAN ConvNet with L1 and Horizontal FL",
        "gtzan_conv_l1_fl_vert": "GTZAN ConvNet with L1 and Vertical FL",
        "gtzan_softmax_l1_base": "GTZAN Softmax Regression with L1",
        "gtzan_softmax_l1_fl_horiz": "GTZAN Softmax Regression with L1 and Horizontal FL",
        "mnist_softmax_l1_base": "MNIST Softmax Regression with L1",
        "mnist_softmax_l1_fl_2d": "MNIST Softmax Regression with L1 and 2D FL"

    }
    return translation[label]


def make_query(table, columns, orderby):
    column_string = ", ".join(columns)
    orderby_string = ", ".join(orderby)
    return "select {0} from {1} order by {2}".format(
        column_string,
        table,
        orderby_string
    )


def make_argument_parser():
    """
    Creates an ArgumentParser to read the options for this script from
    sys.argv
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("db")
    parser.add_argument("table")
    parser.add_argument("-c", "--columns", nargs='+')
    parser.add_argument("-b", "--orderby", nargs='+')
    parser.add_argument("-x", "--xcolumn")
    parser.add_argument('-l', "--log", action="store_true")
    parser.add_argument('-o', "--out", default=None)
    parser.add_argument('-t', "--title", default=None)
    return parser

if __name__ == "__main__":
    parser = make_argument_parser()
    args = parser.parse_args()
    print("connecting to {0}...".format(args.db))
    engine = create_engine(args.db)
    conn = engine.connect()

    columns = args.columns + args.orderby
    query = make_query(args.table, columns, args.orderby)
    print("executing query '{0}'...".format(query))

    results = [tuple(i) for i in conn.execute(query).fetchall()]

    xcolumn_i = columns.index(args.xcolumn)
    other_xcolumn_i = 0
    if xcolumn_i == len(columns) - 1:
        other_xcolumn_i = xcolumn_i - 1
    elif xcolumn_i == len(columns) - 2:
        other_xcolumn_i = xcolumn_i + 1

    other_xvalues = set([i[other_xcolumn_i] for i in results])

    results_x = sorted(list(set([i[xcolumn_i] for i in results])))

    results_y = {}
    for other in other_xvalues:
        results_y[other] = []
        for r in results:
            if r[other_xcolumn_i] == other:
                results_y[other].append(tuple(r[:-len(args.orderby)]))

    # results_y = [tuple(i[:-len(args.orderby)]) for i in results]
    xlabel = to_natural_lang(args.xcolumn)
    ylabels = [to_natural_lang(i) for i in columns if i not in args.orderby]

    for k, v in results_y.items():
        if args.out is not None:
            out = str(k) + args.out
        else:
            out = args.out
        title = to_natural_lang(args.title) + ' (L1 lambda = ' + str(k) + ')'
        # import ipdb; ipdb.set_trace()
        plot(results_x,
            v,
            xlabel,
            ylabels,
            log=args.log,
            out=out,
            title=title)
